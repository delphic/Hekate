<html>
	<head>
		<meta charset="utf-8">
		<title>Hekate</title>
		<!-- meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';" /-->
		<!-- Consistently get refused to create worker error in console because of CSP, 
		    even when worker-src is specified and you put *, or blob:* and/or filesystem:*
		    so at a bit of a loss how to solve that, so comment out again for now
		-->
		<style>
html { padding: 0; margin: 0; }
body { padding: 0; margin: 0; background: #EEE; color: #111; font-family: monospace; overflow-y: hidden; }
#editor { height: calc(100% - 60px); }
/* TODO use https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout */
/* Consider fr units https://css-tricks.com/introduction-fr-css-unit/ */ 
fieldset { height: 30px; padding: 0 5px; margin: 0; border: none; }
fieldset div { margin: 5px 0; }
fieldset input, fieldset select { width: 100px; }
fieldset input.button { 
    width: auto; 
    margin: 5px 0 0;
    padding: 5px 10px;
}
fieldset nav { display: inline-block; margin-left: 5px; }
fieldset nav input.button { margin-left: 5px; }
nav input.selected { 
    background-color: white;
    border: 1px solid #666;
    border-radius: 2px;
}

fieldset p { display:inline-block; margin-top: 9px; }
fieldset #fileMode { float: right; }
		</style>
<!-- Would be nice to be able to reuse the ace themes on the rest of the UI -->
	</head>
	<body onkeypress="onKeyPress(event);">
		<fieldset id="controls">
		    <input type="button" class="button" value="New" onclick="createBlankTab();" />
			<input type="button" class="button" value="Open" onclick="openDialog();" />
			<input type="button" class="button" value="Save" onclick="saveCurrentTab();" />
			<input type="button" class="button" value="Close" onclick="closeCurrentTab();" />
			<nav id="tabHolder">
			</nav>
		</fieldset>
		<div id="editor"></div>
		<fieldset id="bottomBar">
		    <p id="logMessage"></p>
		    <p id="fileMode">Plain Text</p>
		</fieldset>
		<script src="libs/ace/ace.js" type="text/javascript" charset="utf-8"></script>
		<script>
// TODO: General ace settings - ideally on change intercept, failing that use onbeforeunload
// ideally would save ace settings directly into config, rather than hand coding a shim
// editor.onChangeMode may be what we need for this (may also want to save session data, so undo/redo
// preserves across reloads)

// TODO: sub to event for editor content changed (once files loaded) 
// and mark tab as changed if appropriate (compare to save lasted value on tab)

// TODO: Store editor session data and restore when switching between tabs 
// TODO: Ability to reorder Tabs

// TODO: Consider backup process which saves config and back-ups of unsaved changes in case of 
// crash - currently config saves only on reload and exit

// TODO: Would be kinda nice to be able to load ace and electron documentation inside this editor
// Would also be nice to have markdown / HTML preview windows - feels like if we can render arbitary 
// pages in tabs we can easily build an editor - should we be using the main program to control this?
// It would be nice to be able to have deattachable separate windows, and the ability to merge and split.

const { app, dialog } = require('electron').remote;
const currentWindow = require('electron').remote.getCurrentWindow();

var fs = require('fs');
var FileTab = require('./src/fileTab')

var lastOpenedFilePath = "";
var currentFilePath = "";

var configPath = app.getPath('userData') + "/config.json";
var config = require('./src/config').load(configPath);

var tabs = [];
var tabElements = [];
var currentTabIndex = -1;

var editor = ace.edit("editor");

/* Utils */
var removeAllChildNodes = function(element) {
  while (element && element.firstChild) {
      element.removeChild(element.firstChild);
  } 
};

var getFileNamesInDir = function(path) {
	let files = fs.opendirSync(path, "utf-8");
	let file = files.readSync();

	let fileNames = [];
	while (file && file.isFile()) {
		fileNames.push(file.name);
		file = files.readSync();
	}
	return fileNames;
};

var getFileExtension = function(filePath) {
    // https://stackoverflow.com/questions/190852/how-can-i-get-file-extensions-with-javascript/12900504#12900504
    return filePath.slice((filePath.lastIndexOf(".") - 1 >>> 0) + 2);  
};

var getFileName = function(filePath) {
    return filePath.slice(filePath.lastIndexOf("/") + 1);
};

var getPath = function(filePath) {
    return filePath.slice(0, filePath.lastIndexOf("/"));
};

var getUserDocumentsPath = function() {
    return "/home/pi/Documents/"; // TODO: Don't hardcode this!
};

/* Editor Display Updates */
var logMessage = function(message) {
    // TODO: should probably escape this
    if (currentTabIndex >= 0 && currentTabIndex < tabs.length) {
        tabs[currentTabIndex].lastMessage = message;
    }
    document.getElementById("logMessage").innerHTML = message;
    // Clear after timeout?
};

var logError = function(error) {
    if (currentTabIndex >= 0 && currentTabIndex < tabs.length) {
        tabs[currentTabIndex].lastMessage = error.message;
    }
    document.getElementById("logMessage").innerHTML = "<span style='color:red'>" + error.message + "</span>";
    console.log(JSON.stringify(error));
};

var setFileModeDisplay = function(filePath, editor) {
    let extension = getFileExtension(filePath);
    let fileMode = "";
    switch(extension)
	{
        case "js":
            editor.session.setMode("ace/mode/javascript");
            fileMode = "JavaScript";
            break;
        case "json":
            editor.session.setMode("ace/mode/json");
            fileMode = "JSON";
            break;
        case "htm":
        case "html":
            editor.session.setMode("ace/mode/html");
            fileMode = "HTML";
            break;
        case "glsl":
            editor.session.setMode("ace/mode/glsl");
            fileMode = "GLSL";
            break;
        case "markdown":
        case "md":
            editor.session.setMode("ace/mode/markdown");
            fileMode = "Markdown";
            break;
        default:
            editor.session.setMode("ace/mode/text");
            fileMode = "Plain Text"
            break;
    }
    updateFileModeDisplay(fileMode);
};

var updateFileModeDisplay = function(fileMode) {
    document.getElementById("fileMode").innerHTML = fileMode;
};

var switchToTab = function(tabIndex, force) {
    if ((currentTabIndex != tabIndex || force) && tabIndex >= 0 && tabIndex < tabs.length) {
    	if (currentTabIndex != tabIndex && currentTabIndex >= 0) {    	
        	tabs[currentTabIndex].dataCache = tabs[currentTabIndex].editor.getValue();
        	tabElements[currentTabIndex].classList.remove("selected"); 
        }

        let tab = tabs[tabIndex];
        if (!tabElements[tabIndex].classList.contains("selected")) {
            tabElements[tabIndex].classList.add("selected");
        }
        
        // TODO: Save Session Data instead and swap it
        // but do this if no session data exists
        tab.editor.setValue(tab.dataCache);
		tab.editor.selection.clearSelection();
		tab.editor.selection.moveCursorTo(0, 0, false);
		tab.editor.session.$undoManager.reset(); 
		// ^^ This feels they don't want us to use this what with the $
        

        currentTabIndex = tabIndex;
        currentFilePath = tab.filePath;
        setFileModeDisplay(tab.filePath, tab.editor);
        logMessage(tab.lastMessage);
    }
};

var createBlankTab = function() {
    // Bit of a hack 
    // should probably seperate the creating new tab from loading functionality
    loadIntoNewTab("");
};


/* File Save / Load */ 
var openDialog = function() {
    // https://www.electronjs.org/docs/api/dialog
	let files = dialog.showOpenDialogSync(currentWindow, {
		title: "Open File",
		defaultPath: currentFilePath ? getPath(currentFilePath) : getUserDocumentsPath(),
		properties: [ "openFile" ]
	});
	if (files && files[0]) {
	    let foundPath = false;
	    for(let i = 0, l = tabs.length; i < l; i++) {
	        if (tabs[i].filePath == files[0]) {
	            foundPath = true;
	            if (currentTabIndex != i) {
    	            switchToTab(i);
	            }
	            break;
	        }
	    }
	    if (!foundPath) {
    	    loadIntoNewTab(files[0]);
	    }
	}
};

var loadIntoNewTab = function(filePath, callback) {
    // Currently reusing editor
    let tab = FileTab.create({ editor: editor });
    let index = tabs.push(tab) - 1;
    tab.index = index;

    let tabElement = document.createElement("input");
    tabElement.type = "button";
    tabElement.className = "button";
    tabElement.value = filePath ? getFileName(filePath) : "New File";
    tabElements.push(tabElement);

    tabElement.onclick = function() {
        switchToTab(index);
    };
    
    document.getElementById("tabHolder").appendChild(tabElement);
    
    if (filePath) {
        tab.loadFile(filePath, function(error, data) {
            if (!error) {
    			switchToTab(index);     
    			// TODO: probably should separate this, but I think log message relys on currentTabIndex being set
    			// So would need to update log message to have a tab context instead
                logMessage("Loaded " + filePath);
                config.update({ openedFilePath: filePath });
                // TODO: Move to config class
            	// TODO: Watch file and notify of external changes
            	if (callback) {
            	    callback();
            	}
            } else {
    			logError(error);
            }
        });        
    } else {
        switchToTab(index);
        callback();
    }
};

var saveCurrentTab = function() {
	if (currentTabIndex >= 0) {
		saveTab(tabs[currentTabIndex]);
	} else {
	    // TODO: Disable button in these circumstances
		logError({ message: "No tab to save!" });
	}
};

var closeCurrentTab = function() {
    if (currentTabIndex >= 0) {
        var tab = tabs[currentTabIndex];
        if (tab.lastSavedData == tab.editor.getValue() || confirm("You have unsaved data, are you sure?")) {
            var element = tabElements[currentTabIndex];
            var filePath = tab.filePath;
            tabs.splice(currentTabIndex, 1);
            tabElements.splice(currentTabIndex, 1);
            document.getElementById("tabHolder").removeChild(element);
            for(let i = 0, l = tabElements.length; i < l; i++) {
                tabElements[i].onclick = function() {
                    switchToTab(i);
                };
            }
            if (currentTabIndex >= tabs.length) {
                currentTabIndex -= 1;
            }
            if (currentTabIndex >= 0) {
                switchToTab(currentTabIndex, true);
            } else {
                // TODO: Better default state
                editor.setValue("");
                setFileModeDisplay("", editor);
                logMessage("");
            }
            
            config.update({ closedFilePath: filePath, focusedTab: currentTabIndex });
        }        
    } else {
	    // TODO: Disable button in these circumstances
        logError({ message: "No tab to close!"});
    }
};

var saveTab  = function(tab) {
    if (tab) {
        let saveAs = false;
    	let filePath = tab.filePath;
    	if (!filePath) {
    	    filePath = dialog.showSaveDialogSync(currentWindow, { 
    	        title: "Save As...",
    	        properties: [ "createDirectory" ]
    	    });
    	    tab.filePath = filePath;
    	    currentFilePath = filePath;
    	    saveAs = true;
    	}
    	
    	if (filePath) {
    	    tab.saveFile(function(error) {
    			if (!error) {
    			    if (saveAs) {
    			        tabElements[tab.index].value = getFileName(filePath);
        			    setFileModeDisplay(tab.filePath, tab.editor);
        			    config.update({ openedFilePath: tab.filePath });
    			    }
    				logMessage("Saved " + filePath); 
    			} else {
    				logError(error);
    			}
    		});
    	}
    }
};

/* Folder Manangement Function  */
var deleteFile = function(filePath) {
	if (filePath && window.confirm("Are you sure?")) {
		// TODO: Consider Undo over confirm https://alistapart.com/article/neveruseawarning/
		fs.unlink(filePath, function(error) {
			if (error) {
				logError(error);
			} else {
				logMessage("Deleted " + filePath);
			}
		});
	}
};

/* Tab independent */
/* Set Hotkeys */
var onKeyPress = function(event) {
    if (event.ctrlKey) {
        switch(event.key)
        {
            case "r": 
                config.save();
                break;
            case "n":
                createBlankTab();
                break;
            case "s":
                saveCurrentTab();
                break;
            case "o":
                openDialog();
                break;
        }
    }
};

// Unload Management
window.addEventListener('beforeunload', function(event) {
    // TODO: Check for unsaved changes and prompt if there are before closing
    /* 
    // To prevent unloading...
    event.preventDefault(); // This is as per spec
    event.returnValue = ''; // This is required by Chrome
    */
    config.aceThemePath = editor.getTheme();
    config.lastFocusedTab = currentTabIndex;
    config.save();
    // ^^ Should bring these under on beforeunload method on config class
});

// Start-up logic
editor.setTheme(config.aceThemePath);
if (config.openFilePaths.length > 0) {
    let nextToLoadIndex = 0;
    var loadNextTab = function() {
        if (nextToLoadIndex < config.openFilePaths.length) {
            let filePath = config.openFilePaths[nextToLoadIndex]; 
            nextToLoadIndex += 1;
            loadIntoNewTab(filePath, loadNextTab); // Create New Tab only plz (no switch to tab)
        } else {
            switchToTab(config.lastFocusedTab, true);
        }
    };
    loadNextTab();    
}
		</script>
		<!--
		<p>Version Info:</p>
		<ul>
			<li>node <script>document.write(process.versions.node)</script></li>
			<li>chrome <script>document.write(process.versions.chrome)</script></li>
			<li>electron <script>document.write(process.versions.electron)</script></li>
		</ul>
		-->
	</body>
</html>